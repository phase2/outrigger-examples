This extension to the README is necessary for all developers working on the
projectname codebase.

## Build Process

As described in the README, the many steps of assembling, installing, and managing
the site have been combined into a few simple commands using
[Grunt Drupal Tasks](https://github.com/phase2/grunt-drupal-tasks).

You can see a list of all available actions by running
```bash
docker-compose -f build.yml run grunt help
```

### Build the Codebase

Our build process downloads all upstream dependencies of the site to assemble
a functional docroot.

  * Create `build/html` directory
  * Validate custom code with static analysis checks
  * Download operational dependencies
  * Set up symlinks from docroot to custom code

### Role of Each Dependency Manager

This action cuts across several different *dependency managers*, which are each
used to control the use of different types of external, Open Source libraries.
The table below illustrates how the downloaded libraries and modules are used
by the system.

| Tool       | Config Files  | Development & QA | Build & Deployment | Production |
| ---------- | ------------- | :--------------: | :----------------: | :--------: |
| Composer   | composer.json |        ✔         |         ✔          |      ✗     |
| npm        | package.json  |        ✔         |         ✔          |      ✗     |

### When To Run

* **First Run/Kitchen Sink**: `rig project setup`
* **After Merging Changes from Upstream**: `docker-compose -f build.yml run grunt`
* **Before Final Feature Branch Push**: `docker-compose -f build.yml run grunt validate`
* **Starting a New Feature:**
    * `git checkout master && git checkout -b <branch>`
    * `docker-compose -f build.yml run grunt`
    * Fetch a Fresh Database (see below)
    * `docker-compose -f build.yml run grunt install`
        * Run with `--no-db-load` to force a clean reinstall.

If `package.json` has changes, you may need to re-run `npm install --force`.

### Installation Practices

#### Install from Scratch

This command guarantees a clean site installation.

```bash
docker-compose -f build.yml run grunt install --no-db-load
```

#### Install from Scratch with Database Fallback

If a database is found in `/opt/backups/latest.sql.gz`, it will be loaded.
Otherwise a fresh site installation will be triggered.

```bash
docker-compose -f build.yml run grunt install --no-db-load
```

#### Install from a Prepared Database

To accelerate development, the Phase2 project infrastructure prepares a nightly database on the latest code. To retrieve it and re-install the site run the following command:

```
docker-compose -f build.yml run cli sh -c "grunt fetch-db && grunt install"
```

Sometimes the above command fails because of quirks with Docker's access to
external DNS. In that case, run as follows:

```
grunt fetch-db --db-path=./build/backups/latest.sql.gz
docker-compose -f build.yml run grunt install
```

This is subject to setting up Node.js and grunt for use in your host machine.

##### fetch-db Options

* Config **project.db**: The default download destination.
* Config **project.backups.url**: Base URL for remote backups.
* Config **project.backups.env**: Default value for the environment argument.
* Option **--db-path**: Override the download location for the database archive. Must include filename.
* Argument **Environment**: May be run with a grunt argument as `grunt fetch-db:qa`. This allows targeting different backup environments. This value is directly appended to the backup URL.

## Git Practices

* Git Flow conventions are in use.
    * Changes committed to `master` should be ready for production.
    * Change committed to `develop` should be technically approved and believed complete by the developer.
    * All work should be done in feature branches, named such as `feature/KEY-123/short-description` and `bug/KEY-246/short-description`.
    * For more information see http://nvie.com/posts/a-successful-git-branching-model/
* Commit messages should always begin with `KEY-123: `, then follow with 20-60 characters explaining the change. This prefix to the commit message ties the commit back to
a specific JIRA issue, similar to how Drupal project commits should always be prefixed `Issue #123 `.
* Never commit CSS or other assets generated by the build process.

All changes should be submitted for code review using a Pull Request. Pull Requests should target the `develop` branch. If you submit the PR before you've done end-to-end testing and code validation on your change include `[WIP]` in the PR title so reviewers know it's not ready for merge.

## Coding Practices

Development will follow these best practices.

### Code Structure and Naming Things

* [Drupal coding](http://www.drupal.org/coding-standards) & [commenting](http://www.drupal.org/node/1354) standards
* Commented out code is technical debt and should be avoided.
    * Must always have comments describing
        * the change the code would create
        * the condition in which the code is uncommented
        * the condition in which the code is removed
    * All developers are responsible for reviewing this each time they come across the code in a new development task.
* Correct spelling when naming things. CamelCase and snake_case are okay, but inconsistent abbreviations, acronyms, and word concatenation without separators is not.

Some of these guidelines are verified by the `grunt phpcs` task, which is run as part of `grunt validate`, in turn a step of the overall build process.

### Code Layout and Scope

* All markup should be defined in templates.
* API functions should be maintained at the bottom of the `.module` file or kept in a separate include file. In Drupal 8, helper functions should be wrapped in classes.
* Form callbacks should contain the minimum code to interact with the Form system, otherwise they should call API functions for options lists, validation logic, and submit handling.
* Menu callbacks should always be in a separate file from `.module`.
* hooks in the .module file should be implemented in the following thematic order:
    * bootstrapping the site
    * defining menu routes
    * defining permissions, access control, and authentication
    * manipulating data structures
    * content display

## How to Add...

### A New Content Type

* Who should sign off on requirements?
* Are update hooks needed?
* Are there any constraints on what can be done?
* Any specific field types or form elements preferred?
* Any existing fields to be reused when possible?
* What kinds of automated testing should be created?
